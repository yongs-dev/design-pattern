package com.mark.designpattern.l_facade;

import org.junit.jupiter.api.Test;

/**
 * <b>퍼사드 패턴 (Facade Pattern)</b><br>
 * 사용하기 복잡한 클래스 라이브러리에 대해 사용하기 편하게 간편한 인터페이스(API)를 구성하기 위한 구조 패턴이다.<br>
 * 퍼사드 패턴은 복잡하게 얽혀 있는 것을 정리해서 사용하기 편한 인터페이스를 고객에게 제공한다.<br> 복잡한 시스템을 알 필요 없이 시스템의 외부에서 단순한 인터페이스를 이용하기만 하면 된다.<br>
 * 퍼사드 패턴은 다른 디자인 패턴과는 다르게 클래스 구조가 정형화 되지 않은 패턴이다. 그냥 퍼사드 클래스를 만들어 적절히 기능 집약화만 해주면 그게 디자인 패턴이 되는 것이다.<br>
 * <br><hr><br>
 * <b>재귀적인 Facade 패턴의 적용</b><br>
 * 재귀적 퍼사드란 다수의 클래스, 다수의 패키지를 포함하고 있는 큰 시스템에 요소 요소 마다 Facade 패턴을 적용하고 다시 그 Facade를 합친 Facade를 만드는 식으로 퍼사드를 재귀적으로 구성하면 시스템은 보다 편리하게 된다.<br>
 * <br><hr><br>
 * <b>패턴 사용 시기</b><br>
 * 1. 시스템이 너무 복잡할 때<br>
 * 2. 간단한 인터페이스를 통해 복잡한 시스템을 접근하도록 하고 싶을 때<br>
 * 3. 시스템을 사용하고 있는 외부와 결합도가 너무 높아 의존성을 낮추기 위할 때<br>
 * <br><hr><br>
 * <b>패턴 장점</b><br>
 * 1. 하위 시스템의 복잡성에서 코드를 분리하여 외부에서 시스템을 사용하기 쉬워진다.<br>
 * 2. 하위 시스템 간의 의존 관계가 많을 경우 이를 감소시키고 의존성을 한 곳으로 모을 수 있다.<br>
 * 3. 복잡한 코드를 감춤으로써 클라이언트가 시스템의 코드를 모르더라도 Facade 클래스만 이해하고 사용 가능하다.<br>
 * <br><hr><br>
 * <b>패턴 단점</b><br>
 * 1. 퍼사드가 앱의 모든 클래스에 결합된 God 객체가 될 수 있다.<br>
 * 2. 퍼사드 클래스 자체가 서브 시스템에 대한 의존성을 가지게 되어 의존성을 완전히 피할 수는 없다.<br>
 */
public class FacadeTest {

    @Test
    public void facadeTest() {
        // 1. Facade 객체 생성
        Facade facade = Facade.getInstance();

        // 2. DB Insert
        facade.insert();

        // 3. 데이터베이스 & 캐싱 & 메세징 로직을 한번에 조회
        facade.run("주몽");
    }
}
